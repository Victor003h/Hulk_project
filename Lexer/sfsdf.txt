class DFA {
public:
    int start_state;
    int total_states;
    std::vector<int> final_states;
    std::set<char> alphabet;
    std::map<int, std::map<char, int>> transitions;
    std::map<int, TokenType> m_final_token_types;

    DFA(int start_state, int total_states, std::vector<int> final_states,
        std::set<char> alphabet, std::map<int, std::map<char, int>> transitions)
        : start_state(start_state), total_states(total_states), final_states(final_states),
          alphabet(alphabet), transitions(transitions) {}

    DFA() {}

    int getStartState() const { return start_state; }

    int nextState(char l, int current_state) const {
        if (transitions.count(current_state) && transitions.at(current_state).count(l)) {
            return transitions.at(current_state).at(l);
        }
        return -1;
    }

    bool is_valid(char symbol) const {
        return alphabet.count(symbol);
    }

    bool is_final_state(int current_state) const {
        return std::find(final_states.begin(), final_states.end(), current_state) != final_states.end();
    }

    bool evualuate(const std::string& input) const {
        int current_state = start_state;
        for (char symbol : input) {
            if (!is_valid(symbol)) return false;
            current_state = nextState(symbol, current_state);
            if (current_state == -1) return false;
        }
        return is_final_state(current_state);
    }

    static DFA load_binary(const std::string& filename = "dfa.bin");
    static void save_binary(const DFA& dfa, const std::string& filename = "dfa.bin");
    static bool existsDfa();
};

class NFA {
public:
    int start_state;
    int total_states;
    std::set<char> alphabet;
    std::map<int, std::map<char, std::vector<int>>> transitions;
    std::vector<int> final_states;
    std::map<int, TokenType> m_final_token_types;

    NFA(int start_state, int total_states, std::vector<int> final_states,
        std::set<char> alphabet, std::map<int, std::map<char, std::vector<int>>> transitions)
        : start_state(start_state), total_states(total_states), final_states(final_states),
          alphabet(alphabet), transitions(transitions) {}

    static NFA emptyRE();
    static NFA epsilonRE();
    static NFA symbolRE(char symbol);
    static NFA UnionRE(const NFA& a1, const NFA& a2);
    static NFA ConcatenationRE(const NFA& a1, const NFA& a2);
    static NFA ClousureRE(const NFA& a1);

    bool is_valid(char symbol) const {
        return alphabet.count(symbol);
    }

    bool is_final_state(int current_state) const {
        return std::find(final_states.begin(), final_states.end(), current_state) != final_states.end();
    }

    std::vector<int> nextStates(char l, int current_state) const {
        if (!is_valid(l)) return {};
        if (!transitions.count(current_state) || !transitions.at(current_state).count(l)) return {};
        return transitions.at(current_state).at(l);
    }

    std::vector<int> epsilonTransitions(int state) const {
        if (!transitions.count(state) || !transitions.at(state).count('$')) return {};
        return transitions.at(state).at('$');
    }

    std::set<int> eClousure(int state) const {
        std::set<int> res;
        std::queue<int> q;
        q.push(state);
        while (!q.empty()) {
            int s = q.front(); q.pop();
            if (res.count(s)) continue;
            res.insert(s);
            for (int t : epsilonTransitions(s)) q.push(t);
        }
        return res;
    }

    std::set<int> eClousure_set(const std::set<int>& states) const {
        std::set<int> res;
        for (int s : states) {
            std::set<int> clo = eClousure(s);
            res.insert(clo.begin(), clo.end());
        }
        return res;
    }

    std::set<int> move(const std::set<int>& states, char symbol) const {
        std::set<int> result;
        for (int s : states) {
            auto next = nextStates(symbol, s);
            result.insert(next.begin(), next.end());
        }
        return result;
    }

    bool evualuate(const std::string& input) const {
        std::set<int> current = eClousure(start_state);
        for (char c : input) {
            std::set<int> next;
            for (int s : current) {
                std::vector<int> ns = nextStates(c, s);
                for (int t : ns) {
                    auto eps = eClousure(t);
                    next.insert(eps.begin(), eps.end());
                }
            }
            current = std::move(next);
        }
        for (int s : current) {
            if (is_final_state(s)) return true;
        }
        return false;
    }

    DFA convertToDFA() const;
};
